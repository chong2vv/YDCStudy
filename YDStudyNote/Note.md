# 学习笔记

## 数据类型
- 基本数据类型
- 枚举类型
- void类型
- 派生类型

### 常用基本数据类型占用空间（64位机器为例）
char ： 1个字节
int ：4个字节
float：4个字节
double：8个字节

### 基本类型书写
#### 整数
- 默认为10进制 ，10 ，20。
- 以0开头为8进制，045，021。
- 以0b开头为2进制，0b11101101。
- 以0x开头为16进制，0x21458adf。

#### 小数
- 单精度常量：2.3f 。
- 双精度常量：2.3，默认为双精度。

#### 字符型常量
用英文单引号括起来，只保存一个字符'a'、'b' 、'*' ，还有转义字符 '\n' 、'\t'。

#### 字符串常量
用英文的双引号引起来 可以保存多个字符："abc"。

### void类型

```c
/**
 * 测试函数
 */
void basic_data() {
    // 指针指向 void
    void *malloc(size_t size);
}

/**
 * 函数返回为空
 * @param status
 */
void exit (int status) {
    printf("%d", status);
}

/**
 * 函数参数为空
 * @return
 */
int rand(void ) {

    return 0;
}
```

## 常量

#define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！
const 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。

define 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。

1、两者的区别

1. 编译器处理方式不同
   - #define 宏是在预处理阶段展开。
   - const 常量是编译运行阶段使用。
2. 类型和安全检查不同
   - #define 宏没有类型，不做任何类型检查，仅仅是展开。
   - const 常量有具体的类型，在编译阶段会执行类型检查。
3. 存储方式不同
   - #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
   - const常量会在内存中分配(可以是堆中也可以是栈中)。
4. const 可以节省空间，避免不必要的内存分配。 例如：
    ```c
    #define NUM 3.14159 //常量宏
    const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......
    double i = Num; //此时为Pi分配内存，以后不再分配！
    double I= NUM; //编译期间进行宏替换，分配内存
    double j = Num; //没有内存分配
    double J = NUM; //再进行宏替换，又一次分配内存！
    ```
    const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。
5. 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

6. 宏替换只作替换，不做计算，不做表达式求解; 
7. 宏预编译时就替换了，程序运行时，并不分配内存。

## 存储类 
存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：
- auto
- register
- static
- extern

### auto 存储类
**auto** 存储类是所有局部变量默认的存储类
```c
{
   int mount;
   auto int month;
}
```
上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。

### register 存储类
**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&' 运算符（**因为它没有内存位置**）。
```c
{
   register int  miles;
}
```
寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

### static 存储类
**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

以下实例演示了 static 修饰全局变量和局部变量的应用：
```c
#include <stdio.h>
 
/* 函数声明 */
void func1(void);
 
static int count=10;        /* 全局变量 - static 是默认的 */
 
int main()
{
  while (count--) {
      func1();
  }
  return 0;
}
 
void func1(void)
{
/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次
 * 每次调用函数 'func1' 'thingy' 值不会被重置。
 */                
  static int thingy=5;
  thingy++;
  printf(" thingy 为 %d ， count 为 %d\n", thingy, count);
}
```

### extern 存储类
**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

第一个文件：main.c
```c
#include <stdio.h>
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
```

第二个文件：support.c
```c
#include <stdio.h>
 
extern int count;
 
void write_extern(void)
{
   printf("count is %d\n", count);
}
```